#!/bin/sh

dashless="${0##*/}"
dashless="${dashless%%-*} ${dashless#*-}"

# This variable is consulted by the code in "git-sh-setup", which is sourced
# below -- we don't need to export the variable.
# shellcheck disable=SC2034
OPTIONS_SPEC="${dashless} [<options>]

${dashless} changes the dates of one or more git commits according to an interactively-specified scheme.
--
d,debug             show diagnostic output
c,commits=<commits> number of commits to re-date (default: 5)
l,limit=<limit>     number of commits to re-date in a single batch (default: 20)
a,all               re-date all commits
"

# Allow running this command from a subdirectory of the working tree
# shellcheck disable=SC1091
SUBDIRECTORY_OK=yes . "$(git --exec-path)/git-sh-setup"


make_editor_choice() {

    echo 'Which editor do you want to use for this repo?'
    echo '1. VI'
    echo '2. NANO'
    echo '3. Your own'
    echo 'You Choose: '

    read -r CHOOSE_EDITOR
}

get_editor_executable() {

    echo 'What is the path to your prefered test editor?'
    read -r EDITOR_PATH
}


is_has_editor() {
    SETTINGS_FILE=~/.redate-settings
    if [ -f "$SETTINGS_FILE" ]
    then
        OUR_EDITOR=$(cat ${SETTINGS_FILE});
    elif [ -n "${EDITOR:-}" ]
    then
	OUR_EDITOR="$EDITOR";
    else
        make_editor_choice
        if [ "$CHOOSE_EDITOR" = 3 ]; then
            get_editor_executable
            OUR_EDITOR=${EDITOR_PATH}
        elif [ "$CHOOSE_EDITOR" = 1 ]; then
            OUR_EDITOR="vi";
        else
            OUR_EDITOR="nano";
        fi
        echo "$OUR_EDITOR" > "$SETTINGS_FILE"
    fi
}

is_has_editor


ALL=0
DEBUG=0
LIMITCHUNKS=20

while [ "$#" -ge 1 ]
do
key="$1"

case $key in
    -c| --commits)
    COMMITS="$2"
    if [ -z "${COMMITS}" ]; then COMMITS="5"; fi;
    shift
    ;;
    -l| --limit)
    LIMITCHUNKS="$2"
    if [ -z "${LIMITCHUNKS}" ]; then LIMITCHUNKS="20"; fi;
    shift
    ;;
    -d| --debug)
    DEBUG=1
    ;;
    --no-debug)
    DEBUG=0
    ;;
    -a| --all)
    ALL=1
    ;;
    --no-all)
    ALL=0
    ;;
    --)
    shift
    break
    ;;
    *)
    # unknown option
    ;;
esac
shift
done

croak () {
    # `die` is from git-sh-setup
    die "${dashless}: $*"
}

GIT_DIR="${GIT_DIR:-$(git rev-parse --git-dir 2>/dev/null)}"

if ! tmpfile=$(mktemp "${GIT_DIR:+${GIT_DIR}/}GIT_REDATE.XXXXXXXXXX") || ! [ -f "$tmpfile" ]; then
    croak "could not get tmpfile=[$tmpfile]"
fi

cleanup() {
    rm -f "${tmpfile?}"
}

trap cleanup EXIT

if [ "$DEBUG" = 1 ]; then
    debug() {
        echo "$*" 1>&2
    }
else
    debug() {
        :
    }
fi


datefmt=%cI
if [ "$(git log -n1  --pretty=format:"$datefmt")" = "$datefmt" ];
then
    datefmt=%ci
fi

if [ "${ALL}" -eq 1 ];
then
    git log --pretty=format:"$datefmt | %H | %s" > "$tmpfile"
else
    if [ -n "${COMMITS+set}" ]
    then
        git log -n "$COMMITS" --pretty=format:"$datefmt | %H | %s" > "$tmpfile"
    else
        git log -n 5 --pretty=format:"$datefmt | %H | %s" > "$tmpfile"
    fi
fi

${VISUAL:-${EDITOR:-${OUR_EDITOR}}} "$tmpfile"


ITER=0
COLITER=0

COUNTCOMMITS=$(awk 'END {print NR}' "$tmpfile")

while read -r commit || [ -n "$commit" ]; do

    IFS="|" read -r date hash _ <<COMMIT
$commit
COMMIT

    date_lc="$(echo "$date" | tr '[:upper:]' '[:lower:]')"
    if [ "$date_lc" = 'now' ]; then
        date=$(date +%Y-%m-%dT%H:%M:%S%z);
    fi

    if [ "$datefmt" = "%cI" ]
    then
        DATE_NO_SPACE="$(echo "${date}" | tr -d '[:space:]')"
    else
        DATE_NO_SPACE="$date"
    fi


    # `COMMIT_ENV` is used in an `eval` below; silence warning about unused
    # variable.
    # shellcheck disable=SC2034
    COMMIT_ENV=$(cat <<-END
if [ \$GIT_COMMIT = $hash ];
then
    export GIT_AUTHOR_DATE="$DATE_NO_SPACE"
    export GIT_COMMITTER_DATE="$DATE_NO_SPACE";
fi;
END
)

    if [ $((ITER % LIMITCHUNKS)) = 0 ]
    then
        COLITER="$((COLITER+1))"
        debug "Chunk $COLITER Started"
    fi

    ITER="$((ITER + 1))"

    eval "__GIT_REDATE_COLLECTION_${COLITER}=\"\${__GIT_REDATE_COLLECTION_${COLITER}:-}\${COMMIT_ENV}\""

    debug "Commit $ITER/$COUNTCOMMITS Collected"

    if [ $((ITER % LIMITCHUNKS)) = 0 ];
    then
        debug "Chunk $COLITER Finished"
    fi
done < "$tmpfile"

rc=0
ITERATOR=1
while [ "$ITERATOR" -le "$COLITER" ]
do
    each=""
    eval "each=\"\$__GIT_REDATE_COLLECTION_${ITERATOR}\""

    debug "Chunk $ITERATOR/$COLITER Started"

    if [ "${ALL}" -eq 1 ];
    then
        git filter-branch -f --env-filter "$each" -- --all || rc="$?"
    else
        git filter-branch -f --env-filter "$each" "HEAD~${COMMITS}"..HEAD || rc="$?"
    fi

    debug "Chunk $ITERATOR/$COLITER Finished"

    ITERATOR="$((ITERATOR+1))"
done

if [ "$rc" = 0 ] ; then
    echo "Git commit dates updated. Run 'git push -f BRANCH_NAME' to push your changes."
else
    echo "Git redate failed. Please make sure you run this on a clean working directory."
    exit "$rc"
fi
