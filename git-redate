#!/bin/sh

dashless="${0##*/}"
dashless="${dashless%%-*} ${dashless#*-}"

# This variable is consulted by the code in "git-sh-setup", which is sourced
# below -- we don't need to export the variable.
# shellcheck disable=SC2034
OPTIONS_SPEC="${dashless} [<options>]

${dashless} changes the dates of one or more git commits according to an interactively-specified scheme.
--
d,debug             show diagnostic output
c,commits=<commits> number of commits to re-date (default: 5)
l,limit=<limit>     number of commits to re-date in a single batch (default: 20)
a,all               re-date all commits
n,dry-run           show re-dating commands, but do not execute them
"

# Allow running this command from a subdirectory of the working tree
# shellcheck disable=SC1091
SUBDIRECTORY_OK=yes . "$(git --exec-path)/git-sh-setup"

diag() {
    echo "$@" 1>&2
}

while [ "$#" -ge 1 ]
do
key="$1"

case $key in
    -c| --commits)
    COMMITS="$2"
    shift
    ;;
    -l| --limit)
    LIMITCHUNKS="$2"
    shift
    ;;
    -d| --debug)
    DEBUG=1
    ;;
    --no-debug)
    DEBUG=0
    ;;
    -a| --all)
    ALL=1
    ;;
    --no-all)
    ALL=0
    ;;
    -n| --dry-run)
    DRY_RUN=1
    ;;
    --no-dry-run)
    DRY_RUN=0
    ;;
    --)
    shift
    break
    ;;
    *)
    # unknown option
    ;;
esac
shift
done

git_config_get_cond() {
    setting="${1?}"
    shift

    current="${1:-}"
    shift

    default="${1?}"
    shift

    if [ -n "${current:-}" ]; then
        final="$current"
    else
        from_config="$(git config "$@" --get "${setting?}")" || {
            case "$?" in
                128)
                    return 128
                    ;;
            esac
        }

        if [ -n "$from_config" ]; then
            final="$from_config"
        else
            final="${default?}"
        fi
    fi

    printf -- '%s' "$final"
}

git_config_get_bool_cond() {
    raw="$(git_config_get_cond "$@" --bool)" || return

    case "$raw" in
        true)
            printf -- '1'
            ;;
        false)
            printf -- '0'
            ;;
        *)
            printf -- '%s' "$raw"
    esac
}

git_config_get_posint_cond() {
    raw="$(git_config_get_cond "$@" --type int)" || return

    if [ -z "$raw" ] || [ "$raw" -lt 1 ]; then
        die "fatal: bad positive integer config value '${raw}' for '${1?}'"
        return 128
    fi

    printf -- '%d' "$raw"
}

ALL="$(git_config_get_bool_cond redate.all "${ALL:-}" 0)" || exit
COMMITS="$(git_config_get_posint_cond redate.commits "${COMMITS:-}" 5)" || exit
DEBUG="$(git_config_get_bool_cond redate.debug "${DEBUG:-}" 0)" || exit
LIMITCHUNKS="$(git_config_get_posint_cond redate.limit "${LIMITCHUNKS:-}" 20)" || exit

croak () {
    # `die` is from git-sh-setup
    die "${dashless}: $*"
}

GIT_DIR="${GIT_DIR:-$(git rev-parse --git-dir 2>/dev/null)}"

if ! tmpfile=$(mktemp "${GIT_DIR:+${GIT_DIR}/}GIT_REDATE.XXXXXXXXXX") || ! [ -f "$tmpfile" ]; then
    croak "could not get tmpfile=[$tmpfile]"
fi

cleanup() {
    rm -f "${tmpfile?}"
}

trap cleanup EXIT

if [ "$DEBUG" = 1 ]; then
    debug() {
        diag "$@"
    }
else
    debug() {
        :
    }
fi

if [ "$DRY_RUN" = 1 ]; then
    run() {
        diag "$@"
    }
else
    run() {
        "$@"
    }
fi

datefmt=%cI
if [ "$(git log -n1  --pretty=format:"$datefmt")" = "$datefmt" ];
then
    datefmt=%ci
fi

if [ "${ALL}" -eq 1 ];
then
    git log --pretty=format:"$datefmt | %H | %s" > "$tmpfile"
else
    if [ -n "${COMMITS+set}" ]
    then
        git log -n "$COMMITS" --pretty=format:"$datefmt | %H | %s" > "$tmpfile"
    else
        git log -n 5 --pretty=format:"$datefmt | %H | %s" > "$tmpfile"
    fi
fi

git_editor "$tmpfile" || exit

ITER=0
COLITER=0

COUNTCOMMITS=$(awk 'END {print NR}' "$tmpfile")

while read -r commit || [ -n "$commit" ]; do

    IFS="|" read -r date hash _ <<COMMIT
$commit
COMMIT

    date_lc="$(echo "$date" | tr '[:upper:]' '[:lower:]')"
    if [ "$date_lc" = 'now' ]; then
        date=$(date +%Y-%m-%dT%H:%M:%S%z);
    fi

    if [ "$datefmt" = "%cI" ]
    then
        DATE_NO_SPACE="$(echo "${date}" | tr -d '[:space:]')"
    else
        DATE_NO_SPACE="$date"
    fi


    # `COMMIT_ENV` is used in an `eval` below; silence warning about unused
    # variable.
    # shellcheck disable=SC2034
    COMMIT_ENV=$(cat <<-END
if [ \$GIT_COMMIT = $hash ];
then
    export GIT_AUTHOR_DATE="$DATE_NO_SPACE"
    export GIT_COMMITTER_DATE="$DATE_NO_SPACE";
fi;
END
)

    if [ $((ITER % LIMITCHUNKS)) = 0 ]
    then
        COLITER="$((COLITER+1))"
        debug "Chunk $COLITER Started"
    fi

    ITER="$((ITER + 1))"

    eval "__GIT_REDATE_COLLECTION_${COLITER}=\"\${__GIT_REDATE_COLLECTION_${COLITER}:-}\${COMMIT_ENV}\""

    debug "Commit $ITER/$COUNTCOMMITS Collected"

    if [ $((ITER % LIMITCHUNKS)) = 0 ];
    then
        debug "Chunk $COLITER Finished"
    fi
done < "$tmpfile"

rc=0
ITERATOR=1
while [ "$ITERATOR" -le "$COLITER" ]
do
    each=""
    eval "each=\"\$__GIT_REDATE_COLLECTION_${ITERATOR}\""

    debug "Chunk $ITERATOR/$COLITER Started"

    if [ "${ALL}" -eq 1 ];
    then
        run git filter-branch -f --env-filter "$each" -- --all || rc="$?"
    else
        run git filter-branch -f --env-filter "$each" "HEAD~${COMMITS}"..HEAD || rc="$?"
    fi

    debug "Chunk $ITERATOR/$COLITER Finished"

    ITERATOR="$((ITERATOR+1))"
done

if [ "$rc" = 0 ] ; then
    diag "Git commit dates updated. Run 'git push -f BRANCH_NAME' to push your changes."
else
    diag "Git redate failed. Please make sure you run this on a clean working directory."
    exit "$rc"
fi
